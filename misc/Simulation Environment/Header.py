class SimulationEnvironment():
    def __init__(self):
        self.time = 0 #in microseconds?
        self.hub = InitializeHub(self.time)
        self.devices = self.hub.getAnchors()
        self.nextID = self.devices.length() #Gives each device an ID so specific devices can be referenced after creation
        self.signalList = [] #Keeps track of all signals sent. What information needs to be stored here?
    def InitializeHub():
        #Reads a file, possibly in JSON format, and generates a hub with anchors and nodes as specified in that file.
    def update():
        #Calls update function of each device and the hub, increments time.
        self.time += 1
        nodeMap = self.hub.update()
        if (nodeMap):
            analyze(nodeMap)
        for device in devices:
            device.update()
    def addNode(parameters):
        #Creates a non-anchor device, which will call the wrapper for the DW1000, can tell hub about new device.
        #Parameters thus far noted: X, Y, Z positions, ID, velocities/accelerations, battery life, more?
    def analyze(nodeList):
        #Compares the data generated by the hub with the actual values as specified in this class. This gets called in SimulationEnvironment.update(),
        #when a flag is raised when hub.update() is called, meaning it has finished generating a snapshot of all devices?
        
class Hub():
    #The central hub. Are we simulating processing time for this/communication time for the anchors?
    def __init__(self, time, anchors, nodes):
        self.time = time;
        self.anchors = anchors
        self.nodes = nodes
        
    def associateNode(node):
        self.nodes.append(node)

    def getAnchors():
        return self.anchors

    def generateMap():
        #Begins the process which pings all non-anchor nodes in self.nodes
        
    def pingNode(node):
        #Begins the process in which all/some of the anchors communicate with the specified node.

#Very rough idea of a system of keeping track each devices processing queue, in order to simulate actions over the simulated time
class Action():
    def __init(self, executionTime, function):
        self.executionTime = executionTime
        self.function = function

    def execute():
        self.function

    def getExecutionDelay():
        return self.executionTime

#Same as above, this will be inherited by each devices that needs to perform sequential actions in simulated time
class Simulated():
    def __init__(self, time):
        self.actions = []
        self.time = time
        self.actionTimer = 0

    def update():
        #Possibly a general update() for every non-SimulationEnvironment class?
        self.time += 1
        if self.actions[0]: #Checks if there an action to perform
            if self.actionTimer == 0: #Checks to see if more simulated time is required to perform that action
                self.actions[0].execute() #Executes action
                self.actions.pop(0) #Removes action from list
                if self.actions[0]: #If there is another action, gets how much simulated time necessary before action is finished
                    self.actionTimer = self.actions[0].getExecutionDelay()
            else self.actionTimer -= 1
            
        
